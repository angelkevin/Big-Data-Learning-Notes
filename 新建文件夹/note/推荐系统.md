首先我们的数据来源于爬虫,我们采取爬虫技术获取到每个品类的的若干条函数,把它存到mysql里面,通过我同学写的一个带有图片,商品详细等,类似于京东的网页前端,此时如果说用户注册了,我们会提供一些偏好选项来解决冷启动问题,用户如果进行了一些点击,加入购物车等操作,这个操作就会输出到一个log文件,通过flume对这个文件进行监控,并且通过自定义拦截器先简单清洗一下数据,将数据导入到kafka中,然后再通过kafka将数据写入至hdfs进行存储,然后通过Hive对网站PV,UV进行统计和分析,再将kafka的数据使用sparkSQL读取,并写入MongoDB进行统计和排序,离线推荐是通过Azkaban进行调度的,我设置的是每三天进行一次训练,通过ALS训练出来的Model来计算所有当前用户商品的推荐列表,推荐的过程是:

1. userId和productId做笛卡尔积，产生（userId，productId）的元组
2. 通过模型预测（userId，productId）对应的评分。
3. 将预测结果通过预测分值进行排序。
4. 返回分值最大的K个商品，作为当前用户的推荐列表。

通过ALS计算商品相似度矩阵，该矩阵用于查询当前商品的相似商品并为实时推荐系统服务,通过模型获取相似度矩阵,为实时推荐做准备

实时推荐的触发条件是当用户对商品进行评价的时候,就会触发一次实时计算

（1）用户u 对商品p 进行了评分，触发了实时推荐的一次计算；

（2）选出商品p 最相似的K 个商品作为集合S；

（3）获取用户u 最近时间内的K 条评分，包含本次评分，作为集合RK；

（4）计算商品的推荐优先级，产生<qID,>集合updated_S,将结果保存到mongoDB；

然后更新实时推荐结果



# 离线推荐

综合所有历史数据,利用设定的离线统计算法和离线推荐算法周期性的进行结果统计和保存,计算结果在一定的周期内是固定不变的,变更的评率取决于算法的调度频率;

## 离线统计服务

使用sparksql进行分析和排序,并写入MongoDB

* 历史热门商品统计
* 最近热门商品统计
* 商品平均得分统计

## 离线推荐服务

### 用户商品推荐列表

通过ALS训练出来的Model来计算所有当前用户商品的推荐列表

1. userId和productId做笛卡尔积，产生（userId，productId）的元组

2. 通过模型预测（userId，productId）对应的评分。

3. 将预测结果通过预测分值进行排序。

4. 返回分值最大的K个商品，作为当前用户的推荐列表。

### 商品相似度矩阵

通过ALS计算商品相似度矩阵，该矩阵用于查询当前商品的相似商品并为实时推荐系统服务,通过模型获取相似度矩阵,为实时推荐做准备

# 实时推荐

用户在评价一个商品后,用户就会在这一段时间内对此商品和其类似的商品感兴趣,我们就可以通过商品相似度矩阵来获取相关商品,然后设计算法并加一个惩罚项

（1）用户u 对商品p 进行了评分，触发了实时推荐的一次计算；

（2）选出商品p 最相似的K 个商品作为集合S；

（3）获取用户u 最近时间内的K 条评分，包含本次评分，作为集合RK；

（4）计算商品的推荐优先级，产生<qID,>集合updated_S,将结果保存到mongoDB；